# 2025.11.09 - 루틴 도메인 Phase 4~8 구현

## 1. Phase 4: 루틴 엔티티 구성

### Step 4-1: Routine 엔티티

**`src/routines/entities/routine.entity.ts`**

- `routine_pk`, `user_pk`, `routine_name`, `created_at`, `updated_at` 필드 정의
- `User`와 `ManyToOne`(`onDelete: 'CASCADE'`) 및 `OneToMany`(`routineDays`) 설정
- `(user_pk, routine_name)` 고유 인덱스 추가

### Step 4-2: RoutineDay 엔티티

**`src/routines/entities/routine-day.entity.ts`**

- `routine_day_pk`, `routine_pk`, `user_pk`, `session_date` 및 타임스탬프 컬럼 추가
- `Routine`, `User` 각각과 `ManyToOne` 관계 설정
- `(routine_pk, session_date)` 고유 인덱스 정의
- `RoutineDayWorkout`과의 `OneToMany` 연결

### Step 4-3: RoutineDayWorkout 엔티티

**`src/routines/entities/routine-day-workout.entity.ts`**

- `routine_day_workout_pk`, `routine_day_pk`, `workout_name`, `order`, `notes` 구성
- `(routine_day_pk, order)` 인덱스로 정렬 효율 확보
- `RoutineDay`와 `ManyToOne`, `RoutineDaySet`과 `OneToMany` 관계 설정

### Step 4-4: RoutineDaySet 엔티티

**`src/routines/entities/routine-day-set.entity.ts`**

- `routine_day_set_pk`, `routine_day_workout_pk`, `weight(DECIMAL 5,2)`, `reps` 정의
- `RoutineDayWorkout`과 `ManyToOne`(`onDelete: 'CASCADE'`)

### 추가 작업

- `User` 엔티티에 `routines`, `routineDays` 컬렉션 추가
- `app.module.ts` → TypeORM `entities` 배열 및 `RoutinesModule` 등록

---

## 2. Phase 5: 루틴 생성 API

### DTO 작성

**`src/routines/dto/create-routine.dto.ts`**

- `CreateRoutineDto`, `CreateWorkoutDto`, `CreateSetDto` 정의 (validation 포함)

### 모듈 & 컨트롤러

**`src/routines/routines.module.ts`**, **`src/routines/routines.controller.ts`**

- 루틴 관련 4개 엔티티를 `TypeOrmModule.forFeature`로 주입
- `POST /routines`: JWT 인증 필수로 설정

### 서비스 로직

**`src/routines/routines.service.ts`**

1. 동일 이름 루틴 존재 여부 검사
2. 전체 저장 과정을 `dataSource.transaction`으로 묶어 Routine → RoutineDay → Workout → Set 순서로 생성
3. DB UNIQUE 예외(`ER_DUP_ENTRY`, `23505`)는 `ConflictException`으로 변환
4. 루틴 이름 `trim()` 후 공백일 경우 `BadRequestException`
5. 생성 결과(루틴 정보 + 오늘 RoutineDay + workouts/sets) 반환

---

## 3. Phase 6: 루틴 조회 API

### `GET /routines`

- 사용자 루틴 전체 조회 후 각 루틴의 최신 RoutineDay 로딩
- 응답: `routine_pk`, `routine_name`, `last_session_date`, `workouts`

### `GET /routines/:routine_pk/today`

- 지정 루틴의 오늘 RoutineDay 반환
- 해당 날짜에 기록이 없으면 빈 `workouts`와 루틴 메타만 제공

### `GET /routines/by-date?routine_pk=...&date=YYYY-MM-DD`

- 날짜 형식 검증 실패 시 `BadRequestException`
- RoutineDay 미존재 시 `NotFoundException`
- workouts/sets 포함한 RoutineDay 상세 응답

### 내부 공통 로직

- `getRoutineDayByDateInternal`, `mapRoutineDayWorkouts`, `isValidDate` 유틸 메서드 추가

---

## 4. Phase 7: 루틴 저장(업서트) API

### DTO 확장

- `SaveRoutineDayDto`, `SaveRoutineDayWithDateDto`(날짜 정규식 검증) 추가

### 엔드포인트

- `POST /routines/:routine_pk/days/today`
- `POST /routines/:routine_pk/days`

### 서비스 처리

1. 루틴 존재 여부 확인 (`NotFoundException`)
2. RoutineDay 조회 후 없으면 생성, 있으면 재사용
3. 기존 workouts/sets 삭제 후 요청 데이터 기준 재삽입
4. 전체 과정을 트랜잭션으로 처리
5. 정렬된 workouts/sets 리스트 반환

---

## 5. Phase 8: 루틴 이름 수정 & 삭제

### DTO

- `UpdateRoutineNameDto` (1~100자 문자열, 공백 불가) 추가

### `PATCH /routines/:routine_pk`

- 루틴 존재 여부 확인
- 새 이름 `trim()` 후 공백이면 `BadRequestException`
- 동일 이름 요청 시 기존 정보 그대로 반환
- 중복 이름 존재 시 `ConflictException`
- 변경 완료 후 루틴 메타 반환

### `DELETE /routines/:routine_pk`

- 루틴 존재 확인
- 삭제 후 `{ routine_pk, deleted: true }` 형태로 응답

---

## 6. 이슈 & 대응

- **TypeORM 메타데이터 오류**: 새 엔티티를 `TypeOrmModule`에 명시 등록하여 해결
- **데이터 불일치 위험**: 생성/저장 로직 전반에 트랜잭션 도입
- **루틴 이름 검증**: `trim()` 후 공백인 경우 400 반환하도록 보강

---

## 7. 향후 과제

- 루틴 목록 조회 시 발생 가능한 N+1 쿼리 최적화 (QueryBuilder, JOIN 검토)
- `RoutineDaySet.weight`(decimal) 값 numeric 변환 여부 확인 및 transformer 적용 고려
- Phase 9 (대시보드), Phase 10 (최적화) 단계 구현
- 통합 테스트 및 수동 검증 (`npm run start:dev`, Postman 호출) 진행 필요
