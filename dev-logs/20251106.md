# 2025.11.06 - 사용자 관리 구현 및 코드 품질 개선

## 1. Phase 3: 사용자 관리 (Users) 구현

### Step 3-1: 프로필 조회 API 구현

**`src/users/users.module.ts`** 생성

- TypeORM Repository 주입 설정
- UsersService, UsersController 등록

**`src/users/users.service.ts`** 생성

**구현 로직:**

1. 사용자 조회 (user_pk로)
2. 사용자 없으면 `NotFoundException` 발생
3. password 제외하고 반환

**반환 값:**

```typescript
Omit<User, 'password'>;
```

**`src/users/users.controller.ts`** 생성

- `GET /users/profile` 엔드포인트 생성
- `@UseGuards(JwtAuthGuard)` 적용 (클래스 레벨)
- `@User()` 데코레이터로 현재 사용자 정보 추출

**`src/users/dto/update-profile.dto.ts`** 생성

- `name`: 이름 (선택, 문자열, 최소 1자, 최대 100자)
- `bio`: 자기소개 (선택, 문자열)
- Validation 데코레이터 적용

**`src/app.module.ts`** 업데이트

- `UsersModule` import 추가

**검증:**

- 토큰으로 본인 정보 조회 성공
- 비밀번호 응답에서 제외 확인

---

### Step 3-2: 프로필 수정 API 구현

**`src/users/users.service.ts`** - updateProfile 메서드 구현

**구현 로직:**

1. 사용자 조회 (user_pk로)
2. 사용자 없으면 `NotFoundException` 발생
3. DTO에 있는 필드만 업데이트
   - `name`: null 체크 후 trim, 빈 문자열 체크
   - `bio`: null이면 null, 문자열이면 trim 후 빈 문자열이면 null
4. password 제외하고 반환

**`src/users/users.controller.ts`** - updateProfile 엔드포인트

- `PATCH /users/profile` 엔드포인트 생성
- `@UseGuards(JwtAuthGuard)` 적용 (클래스 레벨)
- `@User()` 데코레이터로 현재 사용자 정보 추출
- UpdateProfileDto를 받아서 처리

**검증:**

- 프로필 수정 후 조회 시 변경된 정보 확인
- 빈 이름 수정 시 400 에러 반환

---

## 2. 전체 로직 검토 및 치명적 오류 수정

### 2-1. JWT Strategy 보안 강화 (치명적 보안 문제)

**문제:**

- JWT 토큰만 검증하고 DB에서 사용자 존재 여부를 확인하지 않음
- 사용자가 삭제되어도 토큰이 유효할 수 있음
- 이메일 변경 시 토큰과 불일치 가능

**해결 방법:**

**`src/auth/jwt.strategy.ts`** 수정

```typescript
async validate(payload: JwtPayload) {
  // ... 기존 코드 ...

  // DB에서 사용자 존재 여부 확인 (사용자 삭제 시 토큰 무효화)
  const user = await this.userRepository.findOne({
    where: { user_pk: userPk },
    select: ['user_pk', 'email'],
  });

  if (!user) {
    throw new UnauthorizedException('사용자를 찾을 수 없습니다');
  }

  // 이메일 일치 확인 (토큰 변조 방지)
  if (user.email !== payload.email) {
    throw new UnauthorizedException('토큰 정보가 일치하지 않습니다');
  }

  return {
    user_pk: user.user_pk,
    email: user.email,
  };
}
```

**결과:**

- 사용자 삭제 시 토큰 자동 무효화
- 이메일 변경 시 토큰 무효화
- 보안 강화

---

### 2-2. renewalToken 이메일 일치 확인 추가 (보안)

**문제:**

- renewalToken에서 사용자 조회 후 이메일 일치 확인 누락
- 토큰 변조 가능성

**해결 방법:**

**`src/auth/auth.service.ts`** 수정

```typescript
// 5. 이메일 일치 확인 (토큰 변조 방지)
if (user.email !== decoded.email) {
	throw new UnauthorizedException('토큰 정보가 일치하지 않습니다');
}
```

**결과:**

- 토큰 변조 방지
- 보안 강화

---

### 2-3. updateProfile null 처리 (치명적 런타임 에러)

**문제:**

- `updateProfileDto.name !== undefined` 체크만 함
- name이 null이면 `null.trim()` 호출 시 런타임 에러 발생
- bio도 동일한 문제

**해결 방법:**

**`src/users/users.service.ts`** 수정

```typescript
// name: null 체크 추가
if (updateProfileDto.name !== undefined && updateProfileDto.name !== null) {
	const trimmedName = updateProfileDto.name.trim();
	if (trimmedName.length === 0) {
		throw new BadRequestException('이름은 비어있을 수 없습니다');
	}
	user.name = trimmedName;
}

// bio: null 처리 명시
if (updateProfileDto.bio !== undefined) {
	if (updateProfileDto.bio === null) {
		user.bio = null;
	} else {
		user.bio = updateProfileDto.bio.trim() || null;
	}
}
```

**결과:**

- null.trim() 에러 방지
- 안전한 null 처리

---

### 2-4. googleLogin DB 에러 처리 추가 (치명적 에러 처리 누락)

**문제:**

- 신규 생성 시 try-catch 없음
- DB UNIQUE 제약 위반 시 적절한 에러 처리 없음
- Race Condition 발생 시 500 에러 반환

**해결 방법:**

**`src/auth/auth.service.ts`** 수정

```typescript
// 4. 둘 다 없으면 신규 회원가입
if (!user) {
	try {
		user = this.userRepository.create({
			email,
			google_id,
			name,
			password: null,
			bio: null,
		});
		user = await this.userRepository.save(user);
	} catch (error) {
		// DB UNIQUE 제약 위반 (Race Condition 또는 이메일/구글ID 중복)
		if (error.code === 'ER_DUP_ENTRY' || error.code === 1062) {
			// 중복 발생 시 다시 조회 시도 (OR 조건)
			user = await this.userRepository.findOne({
				where: [{ email: email }, { google_id: google_id }],
			});
			if (!user) {
				throw new ConflictException('이미 사용 중인 이메일 또는 구글 계정입니다');
			}
		} else {
			throw new InternalServerErrorException('구글 로그인 중 오류가 발생했습니다');
		}
	}
}
```

**결과:**

- Race Condition 처리
- 적절한 에러 메시지 반환

---

### 2-5. googleLogin 이메일 충돌 처리 추가 (보안/로직 문제)

**문제:**

- email로 찾았을 때, 이미 google_id가 있으면 업데이트 안 함
- 하지만 이 경우 에러를 던지지 않고 그냥 넘어감
- 다른 구글 계정과 충돌 시 명확한 에러 메시지 없음

**해결 방법:**

**`src/auth/auth.service.ts`** 수정

```typescript
// 3. email로 찾았으면 google_id 업데이트
if (user) {
	// 이미 google_id가 있는 경우는 다른 구글 계정과 충돌
	if (user.google_id) {
		throw new ConflictException('이미 다른 구글 계정으로 연결된 이메일입니다');
	}
	// google_id가 없으면 추가
	try {
		user.google_id = google_id;
		await this.userRepository.save(user);
	} catch (error) {
		// google_id가 이미 다른 사용자에게 사용 중인 경우
		if (error.code === 'ER_DUP_ENTRY' || error.code === 1062) {
			throw new ConflictException('이미 사용 중인 구글 계정입니다');
		}
		throw new InternalServerErrorException('구글 계정 연결 중 오류가 발생했습니다');
	}
}
```

**결과:**

- 명확한 에러 메시지
- 보안 강화

---

### 2-6. google.strategy.ts 배열/객체 접근 에러 방지 (치명적 런타임 에러)

**문제:**

- `emails[0].value` - emails 배열이 비어있거나 undefined면 런타임 에러
- `name.givenName + ' ' + name.familyName` - name이 없거나 givenName/familyName이 없으면 런타임 에러

**해결 방법:**

**`src/auth/google.strategy.ts`** 수정

```typescript
async validate(
  accessToken: string,
  refreshToken: string,
  profile: any,
  done: VerifyCallback,
): Promise<any> {
  const { id, name, emails } = profile;

  // 필수 필드 검증
  if (!id || !emails || !emails[0] || !emails[0].value) {
    return done(new Error('구글 프로필 정보가 올바르지 않습니다'), null);
  }

  if (!name || !name.givenName || !name.familyName) {
    return done(new Error('구글 이름 정보가 올바르지 않습니다'), null);
  }

  const user = {
    google_id: id,
    email: emails[0].value,
    name: name.givenName + ' ' + name.familyName,
    accessToken,
  };
  done(null, user);
}
```

**결과:**

- 런타임 에러 방지
- 안전한 배열/객체 접근

---

### 2-7. auth.controller.ts req.user 체크 추가 (치명적 런타임 에러)

**문제:**

- `googleAuthCallback`에서 `req.user`를 바로 사용
- GoogleStrategy에서 에러 발생 시 `req.user`가 없을 수 있음
- 런타임 에러 발생 가능

**해결 방법:**

**`src/auth/auth.controller.ts`** 수정

```typescript
async googleAuthCallback(@Req() req) {
  // GoogleStrategy에서 에러 발생 시 req.user가 없을 수 있음
  if (!req.user) {
    throw new UnauthorizedException('구글 로그인에 실패했습니다');
  }

  const tokens = await this.authService.googleLogin(req.user);
  // ... 나머지 코드 ...
}
```

**결과:**

- 런타임 에러 방지
- 안전한 객체 접근

---

### 2-8. 에러 타입 일관성 개선

**문제:**

- `changePassword`에서 사용자 없을 때 `UnauthorizedException` 사용
- `UsersService`에서는 `NotFoundException` 사용
- 일관성 부족

**해결 방법:**

**`src/auth/auth.service.ts`** 수정

```typescript
if (!user) {
	// JWT 인증 후이므로 NotFoundException 사용 (일관성)
	throw new NotFoundException('사용자를 찾을 수 없습니다');
}
```

**결과:**

- 에러 타입 일관성 향상

---

## 3. 줄바꿈 문자 문제 근본적 해결

### 문제점

**Windows 환경에서 CRLF (`\r\n`) 사용:**

- ESLint/Prettier는 LF (`\n`) 기대
- 모든 파일에서 `Delete ␍` 에러 반복 발생
- fe에서는 문제 없었지만 be에서만 발생

### 해결 방법

**`.prettierrc`** 업데이트:

```json
{
	"endOfLine": "auto"
}
```

**`.editorconfig`** 업데이트:

```
end_of_line = auto
```

**`.eslintrc.js`** 업데이트:

```javascript
rules: {
  // ... 기존 규칙 ...
  // endOfLine은 Prettier가 자동 처리하므로 ESLint에서 체크하지 않음
  'prettier/prettier': ['error', { endOfLine: 'auto' }],
}
```

**`.gitattributes`** 생성:

```
# Auto detect text files and perform LF normalization
* text=auto

# Force LF line endings for all text files
*.ts text eol=lf
*.js text eol=lf
*.json text eol=lf
*.md text eol=lf
```

**전체 파일 포맷팅:**

```bash
npm run format
```

**결과:**

- Windows에서 작업해도 CRLF 에러 발생하지 않음
- Prettier가 자동으로 처리
- 향후 생성되는 파일도 자동으로 올바른 줄바꿈 사용

---

## 4. 구현 완료 상태

### 완료된 Phase

- ✅ **Phase 0**: 프로젝트 기본 설정
  - Step 0-1: 환경 변수 설정 ✅
  - Step 0-2: TypeORM 설정 ✅
  - Step 0-3: 공통 응답 포맷 설정 ✅

- ✅ **Phase 1**: 데이터베이스 엔티티 (인증)
  - Step 1-1: User 엔티티 생성 ✅
  - Step 1-2: RefreshToken 엔티티 생성 ✅

- ✅ **Phase 2**: 인증 시스템
  - Step 2-1: JWT 모듈 설정 ✅
  - Step 2-2: 회원가입 API ✅
  - Step 2-3: 로그인 API ✅
  - Step 2-3-1: 구글 로그인 API ✅
  - Step 2-4: JWT 인증 가드 ✅
  - Step 2-5: 토큰 갱신 API ✅
  - Step 2-6: 비밀번호 변경 API ✅

- ✅ **Phase 3**: 사용자 관리
  - Step 3-1: 프로필 조회 API ✅
  - Step 3-2: 프로필 수정 API ✅

### 다음 단계

**Phase 4: 루틴 엔티티**

- Step 4-1: Routine 엔티티 생성
- Step 4-2: RoutineDay 엔티티 생성
- Step 4-3: RoutineDayWorkout 엔티티 생성
- Step 4-4: RoutineDaySet 엔티티 생성

---

## 5. 수정된 파일 목록

1. `src/users/users.module.ts` - 새로 생성
2. `src/users/users.service.ts` - 새로 생성
3. `src/users/users.controller.ts` - 새로 생성
4. `src/users/dto/update-profile.dto.ts` - 새로 생성
5. `src/app.module.ts` - UsersModule import 추가
6. `src/auth/jwt.strategy.ts` - DB 사용자 확인 및 이메일 일치 확인 추가
7. `src/auth/auth.service.ts` - renewalToken 이메일 일치 확인, googleLogin DB 에러 처리 및 이메일 충돌 처리 추가, changePassword 에러 타입 수정
8. `src/users/users.service.ts` - updateProfile null 처리 추가
9. `src/auth/google.strategy.ts` - 배열/객체 접근 에러 방지 추가
10. `src/auth/auth.controller.ts` - req.user 체크 추가
11. `.prettierrc` - endOfLine: "auto"로 변경
12. `.editorconfig` - end_of_line = auto로 변경
13. `.eslintrc.js` - prettier/prettier 규칙에 endOfLine: 'auto' 추가
14. `.gitattributes` - 새로 생성

---

## 6. 코드 품질 평가

### 개선 사항

1. **보안**: ⭐⭐⭐⭐⭐
   - JWT Strategy에서 DB 사용자 확인
   - renewalToken에서 이메일 일치 확인
   - googleLogin에서 이메일 충돌 처리
   - 모든 인증 플로우에서 보안 강화

2. **에러 처리**: ⭐⭐⭐⭐⭐
   - 모든 런타임 에러 가능성 제거
   - 적절한 에러 타입 사용
   - 명확한 에러 메시지

3. **타입 안전성**: ⭐⭐⭐⭐⭐
   - null 체크 완료
   - 배열/객체 접근 안전성 확보
   - 타입 안전한 코드

4. **개발 환경**: ⭐⭐⭐⭐⭐
   - 줄바꿈 문자 문제 근본적 해결
   - Windows 환경에서도 문제 없이 개발 가능

---

## 7. 검증 방법

### 프로필 조회 테스트

```bash
# 프로필 조회
GET http://localhost:3000/users/profile
Headers: Authorization: Bearer <access_token>

# 응답: 사용자 정보 (password 제외)
```

### 프로필 수정 테스트

```bash
# 프로필 수정 (name만)
PATCH http://localhost:3000/users/profile
Headers: Authorization: Bearer <access_token>
Body: {
  "name": "새 이름"
}

# 프로필 수정 (bio만)
PATCH http://localhost:3000/users/profile
Headers: Authorization: Bearer <access_token>
Body: {
  "bio": "새 자기소개"
}

# 프로필 수정 (name + bio)
PATCH http://localhost:3000/users/profile
Headers: Authorization: Bearer <access_token>
Body: {
  "name": "새 이름",
  "bio": "새 자기소개"
}

# 빈 이름 수정 시도 (400 에러)
PATCH http://localhost:3000/users/profile
Headers: Authorization: Bearer <access_token>
Body: {
  "name": "   "
}
```

---

## 8. 주요 개선 사항 요약

### 치명적 오류 수정 (7건)

1. ✅ JWT Strategy 보안 강화 (DB 사용자 확인)
2. ✅ renewalToken 이메일 일치 확인
3. ✅ updateProfile null.trim() 에러 방지
4. ✅ googleLogin DB 에러 처리
5. ✅ googleLogin 이메일 충돌 처리
6. ✅ google.strategy.ts 배열/객체 접근 에러 방지
7. ✅ auth.controller.ts req.user 체크

### 개발 환경 개선

1. ✅ 줄바꿈 문자 문제 근본적 해결
2. ✅ Windows 환경에서도 문제 없이 개발 가능

---

## 9. 다음 작업 예정

**Phase 4: 루틴 엔티티**

- Step 4-1: Routine 엔티티 생성
- Step 4-2: RoutineDay 엔티티 생성
- Step 4-3: RoutineDayWorkout 엔티티 생성
- Step 4-4: RoutineDaySet 엔티티 생성
